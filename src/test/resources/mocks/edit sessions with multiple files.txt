We can cleanly decouple the WireMock response transformation logic by moving it to a dedicated class, e.g., `MockFileResponseTransformer`. This makes the code more maintainable and extensible. Below are the changes required.

---

**1. Adds a new class to handle the response transformation for mock file serving.**

```action
path=src/test/java/io/github/jeddict/ai/test/MockFileResponseTransformer.java
action=create
```
```java
I'd like now to create some basic mocks. they should match the body looking for 
the text "use mock <mock name>" where <mock name> is the name of a file whose content 
the mock shall return.
for example, if the body contains the sentence "use mock dir/update_action.txt"
the mock shall read the file "dir/updae_action.txt" under srcGenerate JUnit Test/resources/mocksI'd like now to create some basic mocks. they should match the body looking for 
the text "use mock <mock name>" where <mock name> is the name of a file whose content 
the mock shall return.
for example, if the body contains the sentence "use mock dir/update_action.txt"
the mock shall read the file "dir/updae_action.txt" under srcGenerate JUnit Test/resources/mocks/**
 * Copyright 2025 the original author or authors from the Jeddict project (https://jeddict.github.io/).
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.jeddict.ai.test;

import com.github.tomakehurst.wiremock.extension.Parameters;
import com.github.tomakehurst.wiremock.http.HttpHeaders;
import com.github.tomakehurst.wiremock.http.Request;
import com.github.tomakehurst.wiremock.http.Response;
import com.github.tomakehurst.wiremock.http.ResponseDefinition;
import com.github.tomakehurst.wiremock.http.ResponseDefinitionBuilder;
import com.github.tomakehurst.wiremock.extension.ResponseTransformer;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * ResponseTransformer for serving mock files based on "use mock <file>".
 *
 * To use: Register with WireMock server using .extensions(this) and refer via name().
 */
public class MockFileResponseTransformer extends ResponseTransformer {

    // Pattern to extract "use mock <path>" instruction from request body
    private static final Pattern MOCK_INSTRUCTION_PATTERN =
            Pattern.compile("use mock\\s+([\\w/\\\\.-]+\\.txt)", Pattern.CASE_INSENSITIVE);

    @Override
    public ResponseDefinition transform(
        Request request,
        ResponseDefinition responseDefinition,
        com.github.tomakehurst.wiremock.common.FileSource files,
        Parameters parameters
    ) {
        String body = request.getBodyAsString();
        Matcher matcher = MOCK_INSTRUCTION_PATTERN.matcher(body);

        if (matcher.find()) {
            String mockFile = matcher.group(1);
            Path mockPath = Path.of("src/test/resources/mocks").resolve(mockFile).normalize();

            if (!mockPath.startsWith(Path.of("src/test/resources/mocks"))) {
                // Security: prevent directory traversal
                return ResponseDefinitionBuilder.responseDefinition()
                        .withStatus(400)
                        .withBody("Invalid mock file path: " + mockFile)
                        .build();
            }

            if (!Files.exists(mockPath)) {
                return ResponseDefinitionBuilder.responseDefinition()
                        .withStatus(404)
                        .withBody("Mock file not found: " + mockFile)
                        .build();
            }
            try {
                String mockContent = Files.readString(mockPath, StandardCharsets.UTF_8);
                return ResponseDefinitionBuilder.responseDefinition()
                        .withStatus(200)
                        .withHeader("Content-Type", "text/plain; charset=UTF-8")
                        .withBody(mockContent)
                        .build();
            } catch (IOException ex) {
                return ResponseDefinitionBuilder.responseDefinition()
                        .withStatus(500)
                        .withBody("Error reading mock file: " + ex.getMessage())
                        .build();
            }
        }

        // Fall-through: request does not specify a mock instruction.
        return ResponseDefinitionBuilder.responseDefinition()
                .withStatus(400)
                .withBody("No 'use mock <mock-file>' instruction found in POST body.")
                .build();
    }

    @Override
    public String getName() {
        return "mock-file-response";
    }

    @Override
    public boolean applyGlobally() {
        return false;
    }
}
```

---

**2. Updates the AIMockServer to use and register the new transformer class.**

```action
path=src/test/java/io/github/jeddict/ai/test/AIMockServer.java
action=update
```
```java
/**
 * Copyright 2025 the original author or authors from the Jeddict project (https://jeddict.github.io/).
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.jeddict.ai.test;

import com.github.tomakehurst.wiremock.WireMockServer;
import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;
import com.github.tomakehurst.wiremock.http.trafficlistener.ConsoleNotifyingWiremockNetworkTrafficListener;
import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.matching.ValueMatcher;
import com.github.tomakehurst.wiremock.http.Request;

/**
 * Standalone class to launch a WireMock server for mocking an OpenAI endpoints.
 *
 * It inspects POST bodies for "use mock <mock-file>", returning its contents
 * from src/test/resources/mocks/<mock-file>.
 *
 * <ul>
 *   <li>The port is controlled by the system property <code>aimockserver.port</code> (default: 8080).</li>
 *   <li>All HTTP traffic is logged to the console for transparency and debugging.</li>
 *   <li>Graceful cleanup: a shutdown hook ensures the server is always stopped cleanly, making sure resources are released on process end.</li>
 *   <li>The main thread blocks, keeping the server alive until an OS interrupt (Ctrl+C/sigkill) or VM shutdown.</li>
 *   <li>Ready for extension: feel free to customize stubs in a collaborative way for deeper integration scenarios.</li>
 * </ul>
 */
public class AIMockServer {

    public static void main(String[] args) {
        // Select port from system property or default to 8080 for convenience.
        int port = Integer.parseInt(System.getProperty("aimockserver.port", "8080"));

        // Register the transformer as an extension
        WireMockServer wireMockServer = new WireMockServer(
            options()
                .port(port)
                .networkTrafficListener(new ConsoleNotifyingWiremockNetworkTrafficListener())
                .extensions(new MockFileResponseTransformer())
        );
        wireMockServer.start();

        System.out.println("WireMock server started on port: " + port);

        // Register our dynamic stub for POST requests using the transformer
        wireMockServer.stubFor(
            WireMock.post(WireMock.urlMatching(".*"))
                .andMatching(new ValueMatcher<Request>() {
                    @Override
                    public MatchResult match(Request request) {
                        return MatchResult.exactMatch();
                    }
                })
                .willReturn(
                    WireMock.aResponse()
                        .withTransformers("mock-file-response")
                )
        );

        // Graceful shutdown hook
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            wireMockServer.stop();
            System.out.println("WireMock server stopped gracefully");
        }));

        // Block the main thread indefinitely so the process stays alive,
        // acting as a server process until the application is interrupted or terminated.
        try {
            Thread.currentThread().join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("WireMock server main thread exiting (interrupted or shutdown)");
    }
}
```

---

With these collaborative refactoring steps, we've split the transformer logic into a reusable, testable class, and the main server setup code is simplified accordingly.
actionContent: path=src/test/java/io/github/jeddict/ai/test/MockFileResponseTransformer.java
action=create
sourceContent: /**
 * Copyright 2025 the original author or authors from the Jeddict project (https://jeddict.github.io/).
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.jeddict.ai.test;

import com.github.tomakehurst.wiremock.extension.Parameters;
import com.github.tomakehurst.wiremock.http.HttpHeaders;
import com.github.tomakehurst.wiremock.http.Request;
import com.github.tomakehurst.wiremock.http.Response;
import com.github.tomakehurst.wiremock.http.ResponseDefinition;
import com.github.tomakehurst.wiremock.http.ResponseDefinitionBuilder;
import com.github.tomakehurst.wiremock.extension.ResponseTransformer;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * ResponseTransformer for serving mock files based on "use mock <file>".
 *
 * To use: Register with WireMock server using .extensions(this) and refer via name().
 */
public class MockFileResponseTransformer extends ResponseTransformer {

    // Pattern to extract "use mock <path>" instruction from request body
    private static final Pattern MOCK_INSTRUCTION_PATTERN =
            Pattern.compile("use mock\\s+([\\w/\\\\.-]+\\.txt)", Pattern.CASE_INSENSITIVE);

    @Override
    public ResponseDefinition transform(
        Request request,
        ResponseDefinition responseDefinition,
        com.github.tomakehurst.wiremock.common.FileSource files,
        Parameters parameters
    ) {
        String body = request.getBodyAsString();
        Matcher matcher = MOCK_INSTRUCTION_PATTERN.matcher(body);

        if (matcher.find()) {
            String mockFile = matcher.group(1);
            Path mockPath = Path.of("src/test/resources/mocks").resolve(mockFile).normalize();

            if (!mockPath.startsWith(Path.of("src/test/resources/mocks"))) {
                // Security: prevent directory traversal
                return ResponseDefinitionBuilder.responseDefinition()
                        .withStatus(400)
                        .withBody("Invalid mock file path: " + mockFile)
                        .build();
            }

            if (!Files.exists(mockPath)) {
                return ResponseDefinitionBuilder.responseDefinition()
                        .withStatus(404)
                        .withBody("Mock file not found: " + mockFile)
                        .build();
            }
            try {
                String mockContent = Files.readString(mockPath, StandardCharsets.UTF_8);
                return ResponseDefinitionBuilder.responseDefinition()
                        .withStatus(200)
                        .withHeader("Content-Type", "text/plain; charset=UTF-8")
                        .withBody(mockContent)
                        .build();
            } catch (IOException ex) {
                return ResponseDefinitionBuilder.responseDefinition()
                        .withStatus(500)
                        .withBody("Error reading mock file: " + ex.getMessage())
                        .build();
            }
        }

        // Fall-through: request does not specify a mock instruction.
        return ResponseDefinitionBuilder.responseDefinition()
                .withStatus(400)
                .withBody("No 'use mock <mock-file>' instruction found in POST body.")
                .build();
    }

    @Override
    public String getName() {
        return "mock-file-response";
    }

    @Override
    public boolean applyGlobally() {
        return false;
    }
}
action: create
path: src/test/java/io/github/jeddict/ai/test/MockFileResponseTransformer.java
action: FileAction{path='src/test/java/io/github/jeddict/ai/test/MockFileResponseTransformer.java', action='create', content='[content]'}
file: /home/ste/Projects/jeddict-ai/src/test/java/io/github/jeddict/ai/test/MockFileResponseTransformer.java

